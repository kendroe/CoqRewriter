Welcome to Coq 8.7.0 (October 2017)
Skipping rcfile loading.
[Loading ML file z_syntax_plugin.cmxs ... done]
[Loading ML file quote_plugin.cmxs ... done]
[Loading ML file newring_plugin.cmxs ... done]
[Loading ML file thepack.cmxs ... done]
1 subgoal
  
  ============================
  1 + 2 = 4
******* BEGIN *******(App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Construct (Name nat) 2) (Construct (Name nat) 1)) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))******* END *******Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Rewritingnplus(1, 2) == 4ResultFalse
2 subgoals
  
  ============================
  False

subgoal 2 is:
 False = (1 + 2 = 4)
1 subgoal
  
  ============================
  1 + 2 = 4 -> False
******* BEGIN *******(Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Construct (Name nat) 2) (Construct (Name nat) 1)) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))) (Name False))******* END *******prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Ind
Rewritingimplies(nplus(1, 2) == 4, False)Resultnot(nplus(1, 2) == 4)
2 subgoals
  
  ============================
  1 + 2 = 4 -> False

subgoal 2 is:
 (1 + 2 = 4 -> False) = (1 + 2 = 4 -> False)
1 subgoal
  
  ============================
  forall q : nat, q + 1 = 3 -> q + 1 = 4
1 subgoal
  
  ============================
  forall q : nat, q + 1 = 3 -> q + 1 = 4
1 subgoal
  
  q : nat
  H : q + 1 = 3
  ============================
  q + 1 = 4
******* BEGIN *******(App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Var q) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))******* END *******Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
var
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Rewritingnplus(q, 1) == 4listGetVType
Result3 == q
2 subgoals
  
  q : nat
  H : q + 1 = 3
  ============================
  3 = q

subgoal 2 is:
 (3 = q) = (q + 1 = 4)
1 subgoal
  
  ============================
  forall q : nat, q + 1 = 3 -> q + 1 = 4
1 subgoal
  
  ============================
  forall q : nat, q + 1 = 3 -> q + 1 = 4
******* BEGIN *******(Prod (Name q) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 1) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))))******* END *******prod
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(q:Natural: True) implies(nplus(q, 1) == 3, nplus(q, 1) == 4)listGetVType
ResultALL(q:Natural: True) implies(2 == q, False)HEREprod

2 subgoals
  
  ============================
  forall q : nat, 2 = q -> False

subgoal 2 is:
 (forall q : nat, 2 = q -> False) = (forall q : nat, q + 1 = 3 -> q + 1 = 4)
1 subgoal
  
  ============================
  exists q : nat, q + 1 = 3 -> q + 1 = 4
1 subgoal
  
  ============================
  exists q : nat, q + 1 = 3 -> q + 1 = 4
******* BEGIN *******(App (Name ex) (Name nat) (Lambda (Name q) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 1) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))))))******* END *******Appxxx
Here a
Here b
Here 0
Ind
lambda
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
Ind s = Coq.Init.Logic.ex
RewritingEXISTS(q:Natural) implies(nplus(q, 1) == 3, nplus(q, 1) == 4)listGetVType
ResultEXISTS(q:Natural) implies(2 == q, False)HEREprod
HEREprod

2 subgoals
  
  ============================
  exists q : nat, 2 = q -> False

subgoal 2 is:
 (exists q : nat, 2 = q -> False) = (exists q : nat, q + 1 = 3 -> q + 1 = 4)
1 subgoal
  
  ============================
  forall (x : nat) (f : nat -> nat), x = f x /\ x = f (f x)
1 subgoal
  
  ============================
  forall (x : nat) (f : nat -> nat), x = f x /\ x = f (f x)
******* BEGIN *******(Prod (Name x) (Name nat) (Prod (Name f) (Prod (Name x0) (Name nat) (Name nat)) (App (Name and) (App (Name eq) (Name nat) (Rel 2) (App (Rel 1) (Rel 2))) (App (Name eq) (Name nat) (Rel 2) (App (Rel 1) (App (Rel 1) (Rel 2)))))))******* END *******prod
Ind
prod
prod
Ind
Ind
Convert_exp_to_type Coq.Init.Datatypes.nat
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Ind s = Coq.Init.Logic.eq
Ind s = Coq.Init.Logic.and
Convert_exp_to_type ALL(x0:Natural: True) Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) ALL(f:(Natural) -> (Natural): True) x  == apply(f, x) & x  == apply(f, apply(f, x))listGetVType
NameErrorlistGetVType
NameErrorResultALL(x:Natural: True) ALL(f:(Natural) -> (Natural): True) x == apply(f, x)HEREprod
HEREprod
HERE4
CAUGHT
HEREprod
HEREprod
HEREprod

2 subgoals
  
  ============================
  forall (x : nat) (f : nat -> nat), f = x f

subgoal 2 is:
 (forall (x : nat) (f : nat -> nat), f = x f) =
 (forall (x : nat) (f : nat -> nat), x = f x /\ x = f (f x))
1 subgoal
  
  ============================
  forall (x : nat) (f : nat -> nat), f (f (f x)) = f (f x) /\ x = f (f x)
1 subgoal
  
  ============================
  forall (x : nat) (f : nat -> nat), f (f (f x)) = f (f x) /\ x = f (f x)
******* BEGIN *******(Prod (Name x) (Name nat) (Prod (Name f) (Prod (Name x0) (Name nat) (Name nat)) (App (Name and) (App (Name eq) (Name nat) (App (Rel 1) (App (Rel 1) (App (Rel 1) (Rel 2)))) (App (Rel 1) (App (Rel 1) (Rel 2)))) (App (Name eq) (Name nat) (Rel 2) (App (Rel 1) (App (Rel 1) (Rel 2)))))))******* END *******prod
Ind
prod
prod
Ind
Ind
Convert_exp_to_type Coq.Init.Datatypes.nat
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Ind s = Coq.Init.Logic.eq
Ind s = Coq.Init.Logic.and
Convert_exp_to_type ALL(x0:Natural: True) Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) ALL(f:(Natural) -> (Natural): True) apply(f, apply(f, apply(f, x)))  == apply(f, apply(f, x)) & x  == apply(f, apply(f, x))listGetVType
NameErrorlistGetVType
NameErrorlistGetVType
NameErrorResultALL(x:Natural: True) ALL(f:(Natural) -> (Natural): True) x == apply(f, x)HEREprod
HEREprod
HERE4
CAUGHT
HEREprod
HEREprod
HEREprod

2 subgoals
  
  ============================
  forall (x : nat) (f : nat -> nat), f = x f

subgoal 2 is:
 (forall (x : nat) (f : nat -> nat), f = x f) =
 (forall (x : nat) (f : nat -> nat), f (f (f x)) = f (f x) /\ x = f (f x))
1 subgoal
  
  ============================
  forall x : nat, x = 3 -> x + 1 = 4
1 subgoal
  
  ============================
  forall x : nat, x = 3 -> x + 1 = 4
******* BEGIN *******(Prod (Name x) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (Rel 1) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))))******* END *******prod
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) implies(x == 3, nplus(x, 1) == 4)listGetVType
ResultTrue
2 subgoals
  
  ============================
  True

subgoal 2 is:
 True = (forall x : nat, x = 3 -> x + 1 = 4)
1 subgoal
  
  ============================
  forall x : nat, x = 3 -> x + 1 = 4
1 subgoal
  
  ============================
  forall x : nat, x = 3 -> x + 1 = 4
1 subgoal
  
  x : nat
  ============================
  x = 3 -> x + 1 = 4
******* BEGIN *******(Prod (Anonymous) (App (Name eq) (Name nat) (Var x) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Var x) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))))******* END *******prod
Appxxx
Here a
Here b
Here 0
Ind
var
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
var
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Rewritingimplies(x == 3, nplus(x, 1) == 4)ResultTrue
2 subgoals
  
  x : nat
  ============================
  True

subgoal 2 is:
 True = (x = 3 -> x + 1 = 4)
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
1 subgoal
  
  x : nat
  ============================
  x + 1 = 4 -> x = 3
******* BEGIN *******(Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Var x) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))) (App (Name eq) (Name nat) (Var x) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))******* END *******prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
var
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
var
Appxxx
Ind s = Coq.Init.Logic.eq
Rewritingimplies(nplus(x, 1) == 4, x == 3)listGetVType
ResultTrue
2 subgoals
  
  x : nat
  ============================
  True

subgoal 2 is:
 True = (x + 1 = 4 -> x = 3)
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
******* BEGIN *******(Prod (Name x) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 1) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))) (App (Name eq) (Name nat) (Rel 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))))******* END *******prod
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) implies(nplus(x, 1) == 4, x == 3)listGetVType
ResultTrue
2 subgoals
  
  ============================
  True

subgoal 2 is:
 True = (forall x : nat, x + 1 = 4 -> x = 3)
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
1 subgoal
  
  ============================
  forall x : nat, x + 1 = 4 -> x = 3
******* BEGIN *******(Prod (Name x) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 1) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))) (App (Name eq) (Name nat) (Rel 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))))))******* END *******prod
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
rel
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) implies(nplus(x, 1) == 4, x == 3)listGetVType
ResultTrue
2 subgoals
  
  ============================
  True

subgoal 2 is:
 True = (forall x : nat, x + 1 = 4 -> x = 3)
1 subgoal
  
  ============================
  forall (f g : nat -> nat) (x q r : nat),
  f x + g x = 0 -> g (x + 2 + 1) + q + f (3 + x) + r = q + r
1 subgoal
  
  ============================
  forall (f g : nat -> nat) (x q r : nat),
  f x + g x = 0 -> g (x + 2 + 1) + q + f (3 + x) + r = q + r
******* BEGIN *******(Prod (Name f) (Prod (Name x) (Name nat) (Name nat)) (Prod (Name g) (Prod (Name x) (Name nat) (Name nat)) (Prod (Name x) (Name nat) (Prod (Name q) (Name nat) (Prod (Name r) (Name nat) (Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Rel 5) (Rel 3)) (App (Rel 4) (Rel 3))) (Construct (Name nat) 1)) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Rel 5) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 4) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))) (Rel 3)) (App (Rel 6) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1)))) (Rel 4)))) (Rel 2)) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 3) (Rel 2)))))))))******* END *******prod
prod
Ind
Ind
Convert_exp_to_type Coq.Init.Datatypes.nat
prod
prod
Ind
Ind
Convert_exp_to_type Coq.Init.Datatypes.nat
prod
Ind
prod
Ind
prod
Ind
prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
rel
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Construct
Ind
s = Coq.Init.Datatypes.nat i = 1
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Appxxx
rel
Appxxx
Here a
Here b
Here 0
rel
Appxxx
Here a
Here b
Here 0
Appxxx
rel
rel
Appxxx
Here a
Here b
Here 0
rel
rel
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type ALL(x:Natural: True) Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
Convert_exp_to_type ALL(x:Natural: True) Coq.Init.Datatypes.nat
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(f:(Natural) -> (Natural): True) ALL(g:(Natural) -> (Natural): True) ALL(x:Natural: True) ALL(q:Natural: True) ALL(r:Natural: True) implies(nplus(apply(f, x), apply(g, x)) == 0, nplus(nplus(nplus(apply(g, nplus(nplus(x, 2), 1)), q), apply(f, nplus(3, x))), r) == nplus(q, r))ResultALL(f:(Natural) -> (Natural): True) ALL(g:(Natural) -> (Natural): True) ALL(x:Natural: True) implies(0 == nplus(apply(f, x), apply(g, x)), 0 == nplus(apply(f, nplus(x, 3)), apply(g, nplus(x, 3))))HEREprod
HEREprod
HERE4
CAUGHT
HEREprod
HEREprod
HEREprod
HERE4
CAUGHT
HEREprod
HEREprod

2 subgoals
  
  ============================
  forall (f g : nat -> nat) (x : nat) (H : 0 = x f + g f),
  0 = H (g + 3) + x (g + 3)

subgoal 2 is:
 (forall (f g : nat -> nat) (x : nat) (H : 0 = x f + g f),
  0 = H (g + 3) + x (g + 3)) =
 (forall (f g : nat -> nat) (x q r : nat),
  f x + g x = 0 -> g (x + 2 + 1) + q + f (3 + x) + r = q + r)
1 subgoal
  
  ============================
  forall x : nat, 2 * x + 1 = 7
1 subgoal
  
  ============================
  forall x : nat, 2 * x + 1 = 7
******* BEGIN *******(Prod (Name x) (Name nat) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Definition Coq.Init.Nat.mul (Fix (Functions ((Name mul) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Construct (Name nat) 1) (Lambda (Name p) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Rel 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (Rel 1)) (App (Construct (Name nat) 2) (Construct (Name nat) 1))) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))))))))******* END *******prod
Ind
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
Appxxx
rel
Appxxx
Appxxx
Ind s = Coq.Init.Logic.eq
Convert_exp_to_type Coq.Init.Datatypes.nat
RewritingALL(x:Natural: True) nplus(ntimes(2, x), 1) == 7listGetVType
ResultALL(x:Natural: True) x == 3HEREprod
HEREprod

2 subgoals
  
  ============================
  forall x : nat, x = 3

subgoal 2 is:
 (forall x : nat, x = 3) = (forall x : nat, 2 * x + 1 = 7)
1 subgoal
  
  ============================
  forall q x y : nat, x + y = 0 -> y + 3 + x = q
1 subgoal
  
  ============================
  forall q x y : nat, x + y = 0 -> y + 3 + x = q
1 subgoal
  
  q : nat
  ============================
  forall x y : nat, x + y = 0 -> y + 3 + x = q
1 subgoal
  
  q, x : nat
  ============================
  forall y : nat, x + y = 0 -> y + 3 + x = q
1 subgoal
  
  q, x, y : nat
  ============================
  x + y = 0 -> y + 3 + x = q
******* BEGIN *******(Prod (Anonymous) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Var x) (Var y)) (Construct (Name nat) 1)) (App (Name eq) (Name nat) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (App (Definition Coq.Init.Nat.add (Fix (Functions ((Name add) 0 (Prod (Name n) (Name nat) (Prod (Name m) (Name nat) (Name nat))) (Lambda (Name n) (Name nat) (Lambda (Name m) (Name nat) (Case 0 (Lambda (Name n) (Name nat) (Name nat)) (CaseMatch (Rel 2)) (CaseBranches (Rel 1) (Lambda (Name p) (Name nat) (App (Construct (Name nat) 2) (App (Rel 4) (Rel 1) (Rel 2)))))))))) 0)) (Var y) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (App (Construct (Name nat) 2) (Construct (Name nat) 1))))) (Var x)) (Var q)))******* END *******prod
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
var
var
Construct
Ind
s = Coq.Init.Datatypes.nat i = 1
Ind s = Coq.Init.Logic.eq
Appxxx
Here a
Here b
Here 0
Ind
Appxxx
Here a
Here b
Here 0
Appxxx
Here a
Here b
Here 0
var
Appxxx
var
var
Ind s = Coq.Init.Logic.eq
Rewritingimplies(nplus(x, y) == 0, nplus(nplus(y, 3), x) == q)listGetVType
Resultimplies(0 == nplus(y, x), 3 == q)
2 subgoals
  
  q, x, y : nat
  ============================
  0 = y + x -> 3 = q

subgoal 2 is:
 (0 = y + x -> 3 = q) = (x + y = 0 -> y + 3 + x = q)
Appxxx
Here a
Ind
Appxxx
Appxxx
Here a
Ind
Appxxx
Here a
Ind
Appxxx
[1]